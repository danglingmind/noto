generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/// Users are managed by Clerk, but we store them here for workspace/project linkage
model User {
  id               String            @id @default(cuid())
  clerkId          String            @unique
  email            String            @unique
  name             String?
  avatarUrl        String?
  createdAt        DateTime          @default(now())
  annotations      Annotation[]
  mentioning       CommentMention[]  @relation("UserMentioning")
  mentions         CommentMention[]  @relation("UserMentions")
  comments         Comment[]
  createdFolders   Folder[]
  notifications    Notification[]
  projects         Project[]         @relation("UserProjects")
  shareableLinks   ShareableLink[]
  createdTags      Tag[]
  assignedByTasks  TaskAssignment[]  @relation("TaskAssigner")
  assignedTasks    TaskAssignment[]  @relation("TaskAssignee")
  workspaceMembers WorkspaceMember[]
  ownedWorkspaces  Workspace[]       @relation("WorkspaceOwner")
  sentInvitations  WorkspaceInvitation[]
  subscriptions    Subscription[]
  stripeCustomerId String?         @unique

  @@map("users")
}

/// Workspaces group projects and users
model Workspace {
  id        String            @id @default(cuid())
  name      String
  createdAt DateTime          @default(now())
  ownerId   String
  projects  Project[]
  tags      Tag[]
  members   WorkspaceMember[]
  invitations WorkspaceInvitation[]
  owner     User              @relation("WorkspaceOwner", fields: [ownerId], references: [id])
  workspacePlans   WorkspacePlan[]
  subscriptionTier SubscriptionTier @default(FREE)

  @@map("workspaces")
}

/// Membership table for RBAC (Viewer, Commenter, Editor, Admin)
model WorkspaceMember {
  id          String    @id @default(cuid())
  role        Role
  createdAt   DateTime  @default(now())
  userId      String
  workspaceId String
  user        User      @relation(fields: [userId], references: [id])
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  @@unique([userId, workspaceId])
  @@map("workspace_members")
}

/// Projects live inside workspaces
model Project {
  id             String          @id @default(cuid())
  name           String
  description    String?
  createdAt      DateTime        @default(now())
  workspaceId    String
  ownerId        String
  files          File[]
  folders        Folder[]
  notifications  Notification[]
  tags           ProjectTag[]
  owner          User            @relation("UserProjects", fields: [ownerId], references: [id])
  workspace      Workspace       @relation(fields: [workspaceId], references: [id])
  shareableLinks ShareableLink[]

  @@map("projects")
}

/// Files are uploaded to Supabase storage, metadata is stored here
model File {
  id             String          @id @default(cuid())
  fileName       String
  fileUrl        String
  fileType       FileType
  fileSize       Int?
  metadata       Json?
  createdAt      DateTime        @default(now())
  projectId      String
  status         FileStatus      @default(READY)
  updatedAt      DateTime        @updatedAt
  folderId       String?
  annotations    Annotation[]
  tags           FileTag[]
  folder         Folder?         @relation(fields: [folderId], references: [id])
  project        Project         @relation(fields: [projectId], references: [id])
  shareableLinks ShareableLink[]

  @@map("files")
}

/// Annotations link files and comments with advanced targeting
model Annotation {
  id              String           @id @default(cuid())
  annotationType  AnnotationType
  coordinates     Json?
  createdAt       DateTime         @default(now())
  fileId          String
  userId          String
  style           Json?
  target          Json?
  updatedAt       DateTime         @updatedAt
  viewport        ViewportType?
  file            File             @relation(fields: [fileId], references: [id])
  user            User             @relation(fields: [userId], references: [id])
  comments        Comment[]
  notifications   Notification[]
  taskAssignments TaskAssignment[]

  @@map("annotations")
}

/// Comments are threaded discussions on annotations
model Comment {
  id              String           @id @default(cuid())
  text            String
  status          CommentStatus    @default(OPEN)
  createdAt       DateTime         @default(now())
  annotationId    String
  userId          String
  parentId        String?
  mentions        CommentMention[]
  annotation      Annotation       @relation(fields: [annotationId], references: [id])
  parent          Comment?         @relation("CommentReplies", fields: [parentId], references: [id])
  replies         Comment[]        @relation("CommentReplies")
  user            User             @relation(fields: [userId], references: [id])
  notifications   Notification[]
  taskAssignments TaskAssignment[]

  @@map("comments")
}

/// Shareable links for external collaboration without login
model ShareableLink {
  id           String          @id @default(cuid())
  token        String          @unique
  name         String?
  projectId    String?
  fileId       String?
  permissions  SharePermission @default(VIEW_ONLY)
  password     String?
  expiresAt    DateTime?
  maxViews     Int?
  viewCount    Int             @default(0)
  createdBy    String
  createdAt    DateTime        @default(now())
  lastAccessed DateTime?
  creator      User            @relation(fields: [createdBy], references: [id])
  file         File?           @relation(fields: [fileId], references: [id])
  project      Project?        @relation(fields: [projectId], references: [id])

  @@map("shareable_links")
}

/// Notifications for user engagement and updates
model Notification {
  id           String           @id @default(cuid())
  type         NotificationType
  title        String
  message      String
  data         Json?
  userId       String
  projectId    String?
  commentId    String?
  annotationId String?
  read         Boolean          @default(false)
  readAt       DateTime?
  createdAt    DateTime         @default(now())
  annotation   Annotation?      @relation(fields: [annotationId], references: [id])
  comment      Comment?         @relation(fields: [commentId], references: [id])
  project      Project?         @relation(fields: [projectId], references: [id])
  user         User             @relation(fields: [userId], references: [id])

  @@map("notifications")
}

/// User mentions in comments for targeted notifications
model CommentMention {
  id              String   @id @default(cuid())
  commentId       String
  mentionedUserId String
  mentionedBy     String
  createdAt       DateTime @default(now())
  comment         Comment  @relation(fields: [commentId], references: [id])
  mentioner       User     @relation("UserMentioning", fields: [mentionedBy], references: [id])
  mentionedUser   User     @relation("UserMentions", fields: [mentionedUserId], references: [id])

  @@unique([commentId, mentionedUserId])
  @@map("comment_mentions")
}

/// Task assignments for project management
model TaskAssignment {
  id           String       @id @default(cuid())
  commentId    String?
  annotationId String?
  assignedTo   String
  assignedBy   String
  title        String?
  description  String?
  dueDate      DateTime?
  priority     TaskPriority @default(MEDIUM)
  status       TaskStatus   @default(TODO)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  completedAt  DateTime?
  annotation   Annotation?  @relation(fields: [annotationId], references: [id])
  assigner     User         @relation("TaskAssigner", fields: [assignedBy], references: [id])
  assignee     User         @relation("TaskAssignee", fields: [assignedTo], references: [id])
  comment      Comment?     @relation(fields: [commentId], references: [id])

  @@map("task_assignments")
}

/// Folders for organizing files within projects
model Folder {
  id          String   @id @default(cuid())
  name        String
  description String?
  color       String?
  projectId   String
  parentId    String?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  files       File[]
  creator     User     @relation(fields: [createdBy], references: [id])
  parent      Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children    Folder[] @relation("FolderHierarchy")
  project     Project  @relation(fields: [projectId], references: [id])

  @@map("folders")
}

/// Tags for flexible content organization
model Tag {
  id          String       @id @default(cuid())
  name        String
  color       String?
  workspaceId String
  createdBy   String
  createdAt   DateTime     @default(now())
  files       FileTag[]
  projects    ProjectTag[]
  creator     User         @relation(fields: [createdBy], references: [id])
  workspace   Workspace    @relation(fields: [workspaceId], references: [id])

  @@unique([workspaceId, name])
  @@map("tags")
}

/// Many-to-many relationship between files and tags
model FileTag {
  id     String @id @default(cuid())
  fileId String
  tagId  String
  file   File   @relation(fields: [fileId], references: [id])
  tag    Tag    @relation(fields: [tagId], references: [id])

  @@unique([fileId, tagId])
  @@map("file_tags")
}

/// Many-to-many relationship between projects and tags
model ProjectTag {
  id        String  @id @default(cuid())
  projectId String
  tagId     String
  project   Project @relation(fields: [projectId], references: [id])
  tag       Tag     @relation(fields: [tagId], references: [id])

  @@unique([projectId, tagId])
  @@map("project_tags")
}

enum Role {
  VIEWER
  COMMENTER
  EDITOR
  ADMIN
}

enum FileType {
  IMAGE
  PDF
  VIDEO
  WEBSITE
}

enum FileStatus {
  PENDING
  READY
  FAILED
}

enum AnnotationType {
  PIN
  BOX
  HIGHLIGHT
  TIMESTAMP
}

enum ViewportType {
  DESKTOP
  TABLET
  MOBILE
}

enum CommentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
}

enum SharePermission {
  VIEW_ONLY
  COMMENT
  ANNOTATE
}

enum NotificationType {
  COMMENT_ADDED
  COMMENT_REPLY
  COMMENT_MENTION
  COMMENT_RESOLVED
  ANNOTATION_ADDED
  PROJECT_SHARED
  FILE_UPLOADED
  WORKSPACE_INVITE
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  REVIEW
  DONE
  CANCELLED
}

/// Workspace invitations for adding new members
model WorkspaceInvitation {
  id        String    @id @default(cuid())
  token     String    @unique
  email     String
  role      Role
  message   String?
  workspaceId String
  invitedBy String
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  acceptedAt DateTime?
  
  workspace Workspace @relation(fields: [workspaceId], references: [id])
  inviter   User      @relation(fields: [invitedBy], references: [id])

  @@map("workspace_invitations")
}

/// Subscription plans with feature definitions
model SubscriptionPlan {
  id                String            @id @default(cuid())
  name              String            @unique // "free", "pro", "enterprise"
  displayName       String            // "Free", "Pro", "Enterprise"
  description       String?
  price             Decimal           @db.Decimal(10, 2) // Monthly price in USD
  billingInterval   BillingInterval   @default(MONTHLY)
  stripePriceId     String?           @unique // Stripe price ID
  stripeProductId   String?           @unique // Stripe product ID
  isActive          Boolean           @default(true)
  sortOrder         Int               @default(0)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  // Feature limits (stored as JSON for flexibility)
  featureLimits     Json              // See FeatureLimits interface below
  
  // Relations
  subscriptions     Subscription[]
  workspacePlans    WorkspacePlan[]
  
  @@map("subscription_plans")
}

/// User subscriptions to plans
model Subscription {
  id                    String              @id @default(cuid())
  userId                String
  planId                String
  stripeSubscriptionId  String?             @unique
  stripeCustomerId      String?             @unique
  status                SubscriptionStatus  @default(ACTIVE)
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  cancelAtPeriodEnd     Boolean             @default(false)
  canceledAt            DateTime?
  trialStart            DateTime?
  trialEnd              DateTime?
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Relations
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan                  SubscriptionPlan    @relation(fields: [planId], references: [id])
  workspacePlans        WorkspacePlan[]
  usageRecords          UsageRecord[]
  
  @@unique([userId, planId])
  @@map("subscriptions")
}

/// Workspace-specific subscription plans (for team billing)
model WorkspacePlan {
  id              String            @id @default(cuid())
  workspaceId     String
  subscriptionId  String
  planId          String
  isActive        Boolean           @default(true)
  activatedAt     DateTime          @default(now())
  deactivatedAt   DateTime?
  createdAt       DateTime          @default(now())
  
  // Relations
  workspace       Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  subscription    Subscription      @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  plan            SubscriptionPlan  @relation(fields: [planId], references: [id])
  
  @@unique([workspaceId, subscriptionId])
  @@map("workspace_plans")
}

/// Usage tracking for metered features
model UsageRecord {
  id              String            @id @default(cuid())
  subscriptionId  String
  feature         String            // "annotations", "files", "storage"
  usage           Int               @default(0)
  limit           Int               @default(0)
  period          DateTime          // Start of billing period
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  // Relations
  subscription    Subscription      @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  @@unique([subscriptionId, feature, period])
  @@map("usage_records")
}

/// Stripe webhook events for audit trail
model StripeWebhookEvent {
  id              String            @id @default(cuid())
  stripeEventId   String            @unique
  eventType       String
  processed       Boolean           @default(false)
  processedAt     DateTime?
  data            Json              // Full webhook payload
  createdAt       DateTime          @default(now())
  
  @@map("stripe_webhook_events")
}

// Enums
enum BillingInterval {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  PAST_DUE
  TRIALING
  UNPAID
}

enum SubscriptionTier {
  FREE
  PRO
  ENTERPRISE
}
